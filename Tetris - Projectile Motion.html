<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Physics Tetris ‚Äî with Quiz, Speed-ups & Celebrations</title>
<style>
  :root{
    --bg:#0f1221;
    --panel:#11152b;
    --glass:rgba(255,255,255,.06);
    --text:#e8ecf1; --muted:#a8b0c3;
    --accent:#7c5cff; --accent2:#03c3ff;
    --good:#5ad67d; --warn:#ffc857; --bad:#ff6961;
    --grid:rgba(255,255,255,.06);
    --cell-border: rgba(255,255,255,.08);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:radial-gradient(1300px 700px at 60% 18%,#171a36 0%,var(--bg) 70%);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Helvetica,Arial;}
  header{display:flex;align-items:center;justify-content:space-between;padding:16px 24px;}
  header .brand{font-weight:800;letter-spacing:.2px;display:flex;align-items:center;gap:10px}
  header .dot{width:10px;height:10px;border-radius:50%;background:linear-gradient(135deg,var(--accent),var(--accent2));box-shadow:0 0 12px rgba(124,92,255,.7)}
  header .note{color:var(--muted);font-size:12px}

  .app{display:grid;grid-template-columns: minmax(320px, 520px) 1fr; gap:18px; padding:0 24px 24px;}
  @media (max-width:1080px){.app{grid-template-columns:1fr}}
  .panel{background:linear-gradient(180deg,var(--panel),#0c1030);border:1px solid rgba(255,255,255,.06);border-radius:16px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);backdrop-filter:blur(8px)}
  .panel h2{margin:4px 0 8px}
  .hud{display:grid;grid-template-columns: repeat(2,1fr); gap:10px;}
  .metric{background:var(--glass);border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:10px 12px}
  .metric .label{font-size:12px;color:var(--muted)}
  .metric .val{font-weight:800;font-size:20px;margin-top:2px}
  .controls{margin-top:12px;display:flex;gap:8px;flex-wrap:wrap}
  button{appearance:none;border:none;border-radius:12px;padding:10px 14px;font-weight:700;color:#0c0f1e;background:linear-gradient(135deg,var(--accent),var(--accent2));box-shadow:0 8px 18px rgba(3,195,255,.25);cursor:pointer}
  button.secondary{background:#202540;color:var(--text);border:1px solid rgba(255,255,255,.1)}
  .subnote{font-size:12px;color:var(--muted);margin-top:8px}

  .stage-wrap{display:grid;grid-template-columns: auto 220px; gap:14px; align-items:start;}
  @media (max-width:720px){.stage-wrap{grid-template-columns:1fr}}
  .canvas-wrap{position:relative}
  #stage{width:100%;height:auto;max-width:520px;border-radius:16px;background:#0b0e22;border:1px solid rgba(255,255,255,.08)}
  .next-box{background:var(--glass);border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:10px 12px}
  .next-title{font-weight:800;margin-bottom:6px}
  #nextCanvas{width:200px;height:200px;background:#0b0e22;border:1px solid rgba(255,255,255,.08);border-radius:12px}

  /* Toast */
  .toast{
    position: fixed; left: 50%; bottom: 28px; transform: translateX(-50%);
    background: rgba(17,21,43,.95); color: var(--text); padding: 10px 16px;
    border: 1px solid rgba(255,255,255,.1); border-radius: 10px;
    box-shadow: 0 10px 30px rgba(0,0,0,.35); font-weight: 800; z-index: 1000;
    opacity: 0; transition: opacity .18s ease, transform .18s ease; pointer-events:none;
  }
  .toast.show{opacity:1; transform: translateX(-50%) translateY(-4px);}

  /* Modal (quiz + win + gameover) */
  .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.55);z-index:1100}
  .modal[aria-hidden="false"]{display:flex}
  .modal-card{width:min(560px,92vw);background:#11152b;border:1px solid rgba(255,255,255,.08);border-radius:16px;padding:18px;color:var(--text);box-shadow:0 20px 50px rgba(0,0,0,.45)}
  .modal-card h2{margin:0 0 8px}
  .row{display:grid;grid-template-columns: 1fr auto; gap:8px; align-items:center}
  .row input{width:100%;padding:8px 10px;border-radius:10px;border:1px solid rgba(255,255,255,.12);background:var(--glass);color:var(--text);outline:none}
  .row .unit{padding:8px 10px;border-radius:10px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.04);color:var(--muted)}
  .actions{display:flex;gap:10px;margin-top:12px}
  .summary{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin:12px 0 10px}
  .summary .label{font-size:12px;color:var(--muted)}
  .hint{font-size:12px;color:var(--muted);margin-top:8px}
  .ok{color:var(--good)} .bad{color:var(--bad)}
  .kbd{background:#202540;color:#cfe3ff;border:1px solid rgba(255,255,255,.1);padding:2px 6px;border-radius:6px}

  /* Tiny grid lines on stage */
  .gridline{stroke:var(--grid);}

</style>
</head>
<body>
<header>
  <div class="brand"><span class="dot"></span> Physics Tetris</div>
  <div class="note">g = 9.81 m¬∑s‚Åª¬≤ ¬∑ quiz every 5 pieces ¬∑ speed up every 10 pieces</div>
</header>

<main class="app">
  <!-- LEFT: Game stage -->
  <section class="panel">
    <h2>Game</h2>
    <div class="stage-wrap">
      <div class="canvas-wrap">
        <canvas id="stage" width="300" height="600" aria-label="Tetris stage"></canvas>
      </div>

      <div>
        <div class="next-box">
          <div class="next-title">Next</div>
          <canvas id="nextCanvas" width="200" height="200"></canvas>
        </div>

        <div class="panel" style="margin-top:14px;padding:12px">
          <div class="hud">
            <div class="metric"><div class="label">Score</div><div class="val" id="scoreVal">0</div></div>
            <div class="metric"><div class="label">Lines</div><div class="val" id="linesVal">0</div></div>
            <div class="metric"><div class="label">Level</div><div class="val" id="levelVal">1</div></div>
            <div class="metric"><div class="label">Pieces</div><div class="val" id="piecesVal">0</div></div>
          </div>
          <div class="controls">
            <button id="newGameBtn">New game</button>
            <button id="pauseBtn" class="secondary">Pause (P)</button>
          </div>
          <p class="subnote">Controls: <span class="kbd">‚Üê</span>/<span class="kbd">‚Üí</span> move ¬∑ <span class="kbd">‚Üë</span> rotate ¬∑ <span class="kbd">‚Üì</span> soft drop ¬∑ <span class="kbd">Space</span> hard drop ¬∑ <span class="kbd">P</span> pause</p>
        </div>
      </div>
    </div>
  </section>

  <!-- RIGHT: Info -->
  <section class="panel">
    <h2>About</h2>
    <p style="color:var(--muted)">After every 5 pieces, a quick projectile question appears. After every 10 pieces, the fall speed increases. Clear enough lines to win!</p>
    <ul>
      <li>Questions accept answers within <strong>¬±2%</strong>.</li>
      <li>Two attempts; then you‚Äôll see the <em>worked solution</em>.</li>
      <li>Scoring (per clear): 1=100, 2=300, 3=500, 4=800.</li>
    </ul>
    <div class="metric" style="margin-top:8px">
      <div class="label">Target to win</div>
      <div class="val" id="targetVal">20 lines</div>
    </div>
  </section>
</main>

<!-- Toast for line clears -->
<div id="lineToast" class="toast" aria-live="polite"></div>

<!-- Quiz Modal -->
<div id="quizModal" class="modal" aria-hidden="true">
  <div class="modal-card">
    <h2>Quick physics check</h2>
    <p id="quizPrompt">Projectile Motion ‚Äî Question‚Ä¶</p>
    <div class="row">
      <input id="quizAnswer" type="number" step="0.01" placeholder="Enter value" />
      <div class="unit" id="quizUnit">s</div>
    </div>
    <div id="quizFeedback" class="hint"></div>
    <div class="hint">Tolerances ¬±2%. After two tries, we‚Äôll show the worked solution.</div>
    <div class="actions">
      <button id="quizSubmit">Check</button>
      <button id="quizSkip" class="secondary">Skip</button>
    </div>
  </div>
</div>

<!-- Win Modal -->
<div id="winModal" class="modal" aria-hidden="true">
  <div class="modal-card">
    <h2>üéâ Congratulations!</h2>
    <p>You cleared <strong><span id="finalLines">0</span> lines</strong> ‚Äî awesome work!</p>
    <div class="summary">
      <div><span class="label">Score</span><span id="finalScore">0</span></div>
      <div><span class="label">Level</span><span id="finalLevel">1</span></div>
      <div><span class="label">Pieces</span><span id="finalPieces">0</span></div>
    </div>
    <div class="actions">
      <button id="winPlayAgain">Play again</button>
    </div>
  </div>
</div>

<!-- Game Over Modal (safety) -->
<div id="overModal" class="modal" aria-hidden="true">
  <div class="modal-card">
    <h2>Game Over</h2>
    <p>Stack reached the top. Want to try again?</p>
    <div class="actions">
      <button id="overPlayAgain">Play again</button>
    </div>
  </div>
</div>

<script>
/* ==============================
   TETRIS + QUIZ + CELEBRATIONS
   ============================== */

/* ---------- Config ---------- */
const COLS = 10, ROWS = 20, CELL = 28;          // stage dimensions: 10x20
const PIECES_PER_QUIZ = 5;
const PIECES_PER_SPEEDUP = 10;
const LINES_TO_WIN = 20;                         // target lines to win
const START_SPEED = 1.6;                         // cells per second
const SPEEDUP_MULT = 1.15;                       // +15% every speedup
const MAX_SPEED = 18;                            // cap
const G = 9.81;                                  // m/s^2 for quiz
document.getElementById('targetVal').textContent = `${LINES_TO_WIN} lines`;

/* ---------- Canvas & UI ---------- */
const stage = document.getElementById('stage');
stage.width = COLS * CELL;
stage.height = ROWS * CELL;
const ctx = stage.getContext('2d');

const nextCanvas = document.getElementById('nextCanvas');
const nctx = nextCanvas.getContext('2d');

const scoreEl = document.getElementById('scoreVal');
const linesEl = document.getElementById('linesVal');
const levelEl = document.getElementById('levelVal');
const piecesEl = document.getElementById('piecesVal');

const newGameBtn = document.getElementById('newGameBtn');
const pauseBtn = document.getElementById('pauseBtn');

const lineToast = document.getElementById('lineToast');
let toastTimer=null;

const quizModal = document.getElementById('quizModal');
const quizPrompt = document.getElementById('quizPrompt');
const quizUnit = document.getElementById('quizUnit');
const quizAnswer = document.getElementById('quizAnswer');
const quizFeedback = document.getElementById('quizFeedback');
const quizSubmit = document.getElementById('quizSubmit');
const quizSkip = document.getElementById('quizSkip');

const winModal = document.getElementById('winModal');
const finalLines = document.getElementById('finalLines');
const finalScore = document.getElementById('finalScore');
const finalLevel = document.getElementById('finalLevel');
const finalPieces = document.getElementById('finalPieces');
const winPlayAgain = document.getElementById('winPlayAgain');

const overModal = document.getElementById('overModal');
const overPlayAgain = document.getElementById('overPlayAgain');

/* ---------- Tetrominoes ---------- */
const TETROMINOES = [
  {name:'I', color:'#00f0f0', shape:[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]]},
  {name:'J', color:'#3958ff', shape:[[1,0,0],[1,1,1],[0,0,0]]},
  {name:'L', color:'#ff9f1a', shape:[[0,0,1],[1,1,1],[0,0,0]]},
  {name:'O', color:'#ffd700', shape:[[1,1],[1,1]]},
  {name:'S', color:'#00d26a', shape:[[0,1,1],[1,1,0],[0,0,0]]},
  {name:'T', color:'#b25cff', shape:[[0,1,0],[1,1,1],[0,0,0]]},
  {name:'Z', color:'#ff5c5c', shape:[[1,1,0],[0,1,1],[0,0,0]]},
];

function rotate(mat){
  const N = mat.length, M = mat[0].length;
  const res = Array.from({length:M},()=>Array(N).fill(0));
  for(let y=0;y<N;y++) for(let x=0;x<M;x++) res[x][N-1-y]=mat[y][x];
  return res;
}

/* ---------- Game State ---------- */
let board, piece, nextPiece;
let score, lines, level, pieces, speed, gamePaused=false, quizActive=false, gameOver=false;
let lastTS=0, acc=0;

/* ---------- Board Helpers ---------- */
function emptyBoard(){
  return Array.from({length:ROWS},()=>Array(COLS).fill(null));
}
function collide(mat, px, py){
  for(let y=0;y<mat.length;y++){
    for(let x=0;x<mat[y].length;x++){
      if(!mat[y][x]) continue;
      const nx = px+x, ny = py+y;
      if(nx<0 || nx>=COLS || ny>=ROWS) return true;
      if(ny>=0 && board[ny][nx]) return true;
    }
  }
  return false;
}
function merge(mat, px, py, color){
  for(let y=0;y<mat.length;y++){
    for(let x=0;x<mat[y].length;x++){
      if(mat[y][x] && py+y>=0){
        board[py+y][px+x] = color;
      }
    }
  }
}

/* ---------- Piece Management ---------- */
function randTetromino(){
  const base = TETROMINOES[Math.floor(Math.random()*TETROMINOES.length)];
  return { name:base.name, color:base.color, shape:JSON.parse(JSON.stringify(base.shape)), x: Math.floor(COLS/2)-2, y:-2 };
}
function spawnPiece(){
  piece = nextPiece || randTetromino();
  nextPiece = randTetromino();
  drawNext();
  piece.x = Math.floor(COLS/2) - Math.ceil(piece.shape[0].length/2);
  piece.y = -2;

  pieces++;
  piecesEl.textContent = pieces;

  // Speed up every 10 pieces
  if (pieces % PIECES_PER_SPEEDUP === 0) applySpeedup();

  // Quiz every 5 pieces
  if (pieces % PIECES_PER_QUIZ === 0) showQuiz();

  if (collide(piece.shape, piece.x, piece.y)){
    // immediate collision: game over
    openModal(overModal);
    gameOver = true;
    pause();
  }
}
function hardDrop(){
  if (quizActive || gamePaused || gameOver) return;
  while(!collide(piece.shape, piece.x, piece.y+1)) piece.y++;
  lockPiece();
}
function lockPiece(){
  merge(piece.shape, piece.x, piece.y, piece.color);
  // Clear lines if any
  const cleared = clearLines();
  if (cleared>0) celebrateLines(cleared);
  spawnPiece();
}

/* ---------- Clearing & Scoring ---------- */
function clearLines(){
  let cleared=0;
  for(let y=ROWS-1;y>=0;y--){
    if (board[y].every(c=>!!c)){
      // remove row y, add empty top
      board.splice(y,1);
      board.unshift(Array(COLS).fill(null));
      cleared++;
      y++; // recheck same index because rows shifted down
    }
  }
  if (cleared>0){
    const scoreTable = [0, 100, 300, 500, 800];
    score += scoreTable[Math.min(cleared,4)];
    lines += cleared;
    scoreEl.textContent = score;
    linesEl.textContent = lines;
    if (lines >= LINES_TO_WIN) {
      showWin();
    }
  }
  return cleared;
}

/* ---------- Celebrations ---------- */
function toast(msg){
  lineToast.textContent = msg;
  lineToast.classList.add('show');
  clearTimeout(toastTimer);
  toastTimer = setTimeout(()=>lineToast.classList.remove('show'), 2200);
}
function celebrateLines(n){
  const msg = n===1 ? 'Well done! Line complete ‚úÖ'
           : n===2 ? 'Great! Double line! ‚úåÔ∏è'
           : n===3 ? 'Amazing! Triple line! üî•'
           : 'TETRIS! Four lines! üéØ';
  toast(msg);
}
function showWin(){
  openModal(winModal);
  finalLines.textContent = lines;
  finalScore.textContent = score;
  finalLevel.textContent = level;
  finalPieces.textContent = pieces;
  pause();
}

/* ---------- Speed / Level ---------- */
function applySpeedup(){
  level++;
  levelEl.textContent = level;
  speed = Math.min(MAX_SPEED, speed * SPEEDUP_MULT);
}

/* ---------- Rendering ---------- */
function drawCell(x,y,color,alpha=1){
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.fillStyle = color;
  ctx.fillRect(x*CELL, y*CELL, CELL, CELL);
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 1;
  ctx.strokeRect(x*CELL+0.5, y*CELL+0.5, CELL-1, CELL-1);
  ctx.restore();
}
function draw(){
  ctx.clearRect(0,0,stage.width,stage.height);

  // subtle grid background
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,0.04)';
  ctx.lineWidth = 1;
  for (let x=0;x<=COLS;x++){
    ctx.beginPath(); ctx.moveTo(x*CELL+0.5,0); ctx.lineTo(x*CELL+0.5, ROWS*CELL); ctx.stroke();
  }
  for (let y=0;y<=ROWS;y++){
    ctx.beginPath(); ctx.moveTo(0,y*CELL+0.5); ctx.lineTo(COLS*CELL, y*CELL+0.5); ctx.stroke();
  }
  ctx.restore();

  // board
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      const c = board[y][x];
      if (c) drawCell(x,y,c);
    }
  }
  // active piece
  if (piece){
    for(let y=0;y<piece.shape.length;y++){
      for(let x=0;x<piece.shape[y].length;x++){
        if (piece.shape[y][x]){
          const px = piece.x + x, py = piece.y + y;
          if (py>=0) drawCell(px,py,piece.color);
        }
      }
    }
  }
}
function drawNext(){
  nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
  if (!nextPiece) return;
  const mat = nextPiece.shape;
  const cell = 24;
  // compute offset to center
  const w = mat[0].length * cell, h = mat.length * cell;
  const offx = Math.floor((nextCanvas.width - w)/2);
  const offy = Math.floor((nextCanvas.height - h)/2);
  nctx.save();
  // background grid
  nctx.strokeStyle='rgba(255,255,255,0.05)';
  for(let x=0;x<=nextCanvas.width;x+=cell){
    nctx.beginPath(); nctx.moveTo(x+0.5,0); nctx.lineTo(x+0.5,nextCanvas.height); nctx.stroke();
  }
  for(let y=0;y<=nextCanvas.height;y+=cell){
    nctx.beginPath(); nctx.moveTo(0,y+0.5); nctx.lineTo(nextCanvas.width,y+0.5); nctx.stroke();
  }
  // shape
  for(let y=0;y<mat.length;y++){
    for(let x=0;x<mat[y].length;x++){
      if (!mat[y][x]) continue;
      nctx.fillStyle = nextPiece.color;
      nctx.fillRect(offx+x*cell, offy+y*cell, cell, cell);
      nctx.strokeStyle='rgba(255,255,255,0.08)';
      nctx.strokeRect(offx+x*cell+0.5, offy+y*cell+0.5, cell-1, cell-1);
    }
  }
  nctx.restore();
}

/* ---------- Input ---------- */
document.addEventListener('keydown', (e)=>{
  if (quizActive || gameOver) return;
  if (e.key==='p' || e.key==='P'){ togglePause(); return; }
  if (gamePaused) return;

  if (e.key==='ArrowLeft'){
    if (!collide(piece.shape, piece.x-1, piece.y)) { piece.x--; draw(); }
  } else if (e.key==='ArrowRight'){
    if (!collide(piece.shape, piece.x+1, piece.y)) { piece.x++; draw(); }
  } else if (e.key==='ArrowDown'){
    // soft drop
    if (!collide(piece.shape, piece.x, piece.y+1)){ piece.y++; score++; scoreEl.textContent=score; draw(); }
  } else if (e.key==='ArrowUp'){
    const r = rotate(piece.shape);
    if (!collide(r, piece.x, piece.y)){ piece.shape=r; draw(); }
  } else if (e.key===' '){
    e.preventDefault(); hardDrop(); draw();
  }
});

/* ---------- Game Loop ---------- */
function loop(ts){
  if (!lastTS) lastTS = ts;
  const dt = (ts - lastTS)/1000; lastTS = ts;

  if (!gamePaused && !quizActive && !gameOver){
    acc += speed * dt;
    while(acc>=1){
      acc -= 1;
      tick();
    }
    draw();
  }
  requestAnimationFrame(loop);
}

function tick(){
  if (!piece) return;
  if (!collide(piece.shape, piece.x, piece.y+1)){
    piece.y++;
  } else {
    // lock & proceed
    lockPiece();
  }
}

/* ---------- Pause/Resume ---------- */
function pause(){ gamePaused=true; pauseBtn.textContent='Resume (P)'; }
function resume(){ gamePaused=false; pauseBtn.textContent='Pause (P)'; }
function togglePause(){ gamePaused ? resume() : pause(); }

/* ---------- Quiz System ---------- */
let currentQuiz = null;
let quizAttempts = 0;
function openModal(el){ el.setAttribute('aria-hidden','false'); el.style.display='flex'; }
function closeModal(el){ el.setAttribute('aria-hidden','true'); el.style.display='none'; }

function showQuiz(){
  quizActive = true;
  pause();
  quizAttempts = 0;

  // Randomize a projectile set
  const h0 = randInt(0, 10);              // m
  const v0 = randInt(12, 32);             // m/s
  const angle = randInt(20, 70);          // deg
  const theta = angle*Math.PI/180;
  const vx = v0*Math.cos(theta);
  const vy = v0*Math.sin(theta);
  const disc = vy*vy + 2*G*h0;
  const T = (vy + Math.sqrt(disc)) / G;   // s
  const R = vx*T;                         // m
  const ymax = h0 + (vy*vy)/(2*G);        // m

  // Pick a question type
  const qTypes = ['tof','range','vx0','vy0','ymax'];
  const type = qTypes[Math.floor(Math.random()*qTypes.length)];
  let prompt='', unit='';

  if (type==='tof'){ prompt = `Launched at v‚ÇÄ=${v0} m/s at ${angle}¬∞ from height h‚ÇÄ=${h0} m. Find the time of flight.`; unit='s'; }
  if (type==='range'){ prompt = `Launched at v‚ÇÄ=${v0} m/s at ${angle}¬∞ from height h‚ÇÄ=${h0} m. Find the horizontal range.`; unit='m'; }
  if (type==='vx0'){ prompt = `Launched at v‚ÇÄ=${v0} m/s at ${angle}¬∞. Find the initial horizontal velocity v‚Çì‚ÇÄ.`; unit='m/s'; }
  if (type==='vy0'){ prompt = `Launched at v‚ÇÄ=${v0} m/s at ${angle}¬∞. Find the initial vertical velocity v·µß‚ÇÄ.`; unit='m/s'; }
  if (type==='ymax'){ prompt = `Launched at v‚ÇÄ=${v0} m/s at ${angle}¬∞ from height h‚ÇÄ=${h0} m. Find the peak height above ground.`; unit='m'; }

  const correct =
    type==='tof'   ? T :
    type==='range' ? R :
    type==='vx0'   ? vx :
    type==='vy0'   ? vy :
    ymax;

  currentQuiz = { type, h0, v0, angle, vx, vy, T, R, ymax, correct, unit };
  quizPrompt.textContent = prompt;
  quizUnit.textContent = unit;
  quizAnswer.value=''; quizFeedback.textContent='';
  openModal(quizModal);
  quizAnswer.focus();
}

function checkQuiz(){
  const tol = 0.02; // ¬±2%
  const ans = parseFloat(quizAnswer.value);
  if (!isFinite(ans)){ quizFeedback.innerHTML = '<span class="bad">Enter a number.</span>'; return; }

  const ok = Math.abs(ans - currentQuiz.correct) <= Math.abs(currentQuiz.correct) * tol;
  if (ok){
    quizFeedback.innerHTML = '<span class="ok">Correct! Nice work.</span>';
    setTimeout(()=>{ closeModal(quizModal); quizActive=false; resume(); }, 400);
  } else {
    quizAttempts++;
    if (quizAttempts < 2){
      quizFeedback.innerHTML = '<span class="bad">Not quite. Try again.</span>';
    } else {
      // show worked solution
      const q = currentQuiz;
      let work='';
      if (q.type==='tof'){
        work = `v·µß‚ÇÄ = v‚ÇÄ sinŒ∏ = ${(q.vy).toFixed(2)} m/s<br>
                T = (v·µß‚ÇÄ + ‚àö(v·µß‚ÇÄ¬≤ + 2gh‚ÇÄ)) / g = <strong>${q.T.toFixed(2)} s</strong>`;
      } else if (q.type==='range'){
        work = `v‚Çì‚ÇÄ = v‚ÇÄ cosŒ∏ = ${(q.vx).toFixed(2)} m/s; T as above = ${(q.T).toFixed(2)} s<br>
                Range R = v‚Çì‚ÇÄ ¬∑ T = <strong>${q.R.toFixed(2)} m</strong>`;
      } else if (q.type==='vx0'){
        work = `v‚Çì‚ÇÄ = v‚ÇÄ cosŒ∏ = <strong>${q.vx.toFixed(2)} m/s</strong>`;
      } else if (q.type==='vy0'){
        work = `v·µß‚ÇÄ = v‚ÇÄ sinŒ∏ = <strong>${q.vy.toFixed(2)} m/s</strong>`;
      } else { // ymax
        work = `y‚Çò‚Çê‚Çì = h‚ÇÄ + v·µß‚ÇÄ¬≤/(2g) = ${q.h0} + ${(q.vy*q.vy).toFixed(2)}/(2¬∑${G}) = <strong>${q.ymax.toFixed(2)} m</strong>`;
      }
      quizFeedback.innerHTML = `<span class="bad">Answer: <strong>${q.correct.toFixed(2)} ${q.unit}</strong></span><br><span class="hint">${work}</span>`;
      // close after a moment
      setTimeout(()=>{ closeModal(quizModal); quizActive=false; resume(); }, 1200);
    }
  }
}

quizSubmit.addEventListener('click', checkQuiz);
quizSkip.addEventListener('click', ()=>{
  closeModal(quizModal); quizActive=false; resume();
});
quizAnswer.addEventListener('keydown', e=>{ if (e.key==='Enter') checkQuiz(); });

/* ---------- Game Control ---------- */
function reset(){
  board = emptyBoard();
  score = 0; lines = 0; level = 1; pieces = 0; speed = START_SPEED;
  scoreEl.textContent=score; linesEl.textContent=lines; levelEl.textContent=level; piecesEl.textContent=pieces;
  gamePaused=false; quizActive=false; gameOver=false;
  nextPiece = randTetromino();
  spawnPiece();
  acc=0; lastTS=0;
  draw();
}
function startLoop(){ requestAnimationFrame(loop); }

newGameBtn.addEventListener('click', ()=>{ closeModal(winModal); closeModal(overModal); reset(); });
pauseBtn.addEventListener('click', togglePause);
winPlayAgain.addEventListener('click', ()=>{ closeModal(winModal); reset(); });
overPlayAgain.addEventListener('click', ()=>{ closeModal(overModal); reset(); });

/* ---------- Utilities ---------- */
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

/* ---------- Boot ---------- */
reset();
startLoop();
</script>
</body>
</html>